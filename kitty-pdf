#!/usr/bin/env python3
# vim:fileencoding=utf-8
"""\
Usage:
    kitty-pdf example.pdf

Options:
    currently, no options

Key Bindings:
    see the shortcuts at the beginning of the file
"""

__version__ = "0.1"
__license__ = "MIT"
__author__ = "David Sanson"
__url__ = "https://github.com/dsanson/kitty-pdf"

import array
import curses
import fcntl
import fitz
import os
import re
import readchar
import signal
import subprocess
import sys
import termios
import tty
import zlib
from base64 import standard_b64encode
from collections import namedtuple
from io import TextIOWrapper, BytesIO
from math import ceil
from time import sleep, monotonic

# Keyboard shortcuts
GOTO_PAGE     = {ord("G")}
GOTO          = {ord("g")}
NEXT_PAGE     = {ord("j"), curses.KEY_DOWN, ord(" ")}
PREV_PAGE     = {ord("k"), curses.KEY_UP}
NEXT_CHAP     = {ord("l"), curses.KEY_RIGHT}
PREV_CHAP     = {ord("h"), curses.KEY_LEFT}
ROTATE_CW     = {ord("r")}
ROTATE_CCW    = {ord("R")}
TOGGLE_ALPHA  = {ord("a")}
TOGGLE_INVERT = {ord("i")}
TOGGLE_TINT   = {ord("t")}
REFRESH       = {18, curses.KEY_RESIZE}            # CTRL-R
QUIT          = {3, ord("q")}
DEBUG         = {ord("D")}

# Defaults
TINT_COLOR    = "antiquewhite2"
ZINDEX        = -1

def screen_size_function(fd=None):
    # ans = getattr(screen_size_function, 'ans', None)
    # if ans is None:
    Size = namedtuple('Size', 'rows cols width height cell_width cell_height')
    if fd is None:
        fd = sys.stdout

    def screen_size():
        if screen_size.changed:
            buf = array.array('H', [0, 0, 0, 0])
            fcntl.ioctl(fd, termios.TIOCGWINSZ, buf)
            rows, cols, width, height = tuple(buf)
            cell_width, cell_height = width // (cols or 1), height // (rows or 1)
            screen_size.ans = Size(rows, cols, width, height, cell_width, cell_height)
            screen_size.changed = False
        return screen_size.ans
    screen_size.changed = True
    screen_size.Size = Size
    ans = screen_size_function.ans = screen_size

    return ans

def serialize_gr_command(cmd, payload=None):
   cmd = ','.join('{}={}'.format(k, v) for k, v in cmd.items())
   ans = []
   w = ans.append
   w(b'\033_G'), w(cmd.encode('ascii'))
   if payload:
      w(b';')
      w(payload)
   w(b'\033\\')
   return b''.join(ans)

def write_gr_cmd(cmd, payload=None):
    sys.stdout.buffer.write(serialize_gr_command(cmd, payload))
    sys.stdout.flush()

def write_gr_cmd_with_response(cmd, payload=None):
    write_gr_cmd(cmd, payload)
    resp = b''
    while resp[-2:] != b'\033\\':
        resp += sys.stdin.buffer.read(1)
    if b'OK' in resp:
        return True
    else:
        return False

def write_chunked(cmd, data):
    if cmd['f'] != 100:
        data = zlib.compress(data)
        cmd['o'] = 'z'
    data = standard_b64encode(data)
    while data:
        chunk, data = data[:4096], data[4096:]
        m = 1 if data else 0
        cmd['m'] = m
        write_gr_cmd(cmd, chunk)
        cmd.clear()

def set_cursor(x_place, y_place):
    sys.stdout.buffer.write('\033[{};{}f'.format(y_place, x_place).encode('ascii'))

def set_image_cursor(display_width, display_height, ss_width, ss_height):
    x_place_pixels = (ss_width / 2) - (display_width / 2)
    x_place = int(ceil(x_place_pixels / screen_size().cell_width) - 1)
    x_place = max(0,x_place)
    y_place_pixels = (ss_height / 2) - (display_height / 2)
    y_place = int(ceil(y_place_pixels / screen_size().cell_height) - 1)
    y_place = max(0,y_place)
    set_cursor(x_place, y_place)

def clear_screen():
    sys.stdout.buffer.write('\033[2J'.encode('ascii'))
    #subprocess.run('clear')
    #cmd = {'a': 'd', 'd': 'Z', 'z': ZINDEX} 
    #write_gr_cmd(cmd)

def clear_page(n):
    cmd = {'a': 'd', 'i': n + 1}
    write_gr_cmd(cmd)

def display_page(doc, n, opts):
    global is_stale
    page = doc.loadPage(n)
    if opts["rotation"] == 0 or opts["rotation"] == 180:
        page_width = page.bound().width
        page_height = page.bound().height
    else:
        page_width = page.bound().height
        page_height = page.bound().width
    screen_size = screen_size_function()
    ss_width = screen_size().width
    ss_height = (screen_size().height - screen_size().cell_height)
    x_factor = ss_width / page_width
    y_factor = ss_height / page_height
    factor = min(x_factor, y_factor)
    display_width = factor * page_width
    display_height = factor * page_height
    set_image_cursor(display_width, display_height, ss_width, ss_height)
    cmd = {'a': 'p', 'i': n + 1, 'z': ZINDEX}
    if is_stale[n] or not write_gr_cmd_with_response(cmd):
        x_zoom, y_zoom = factor, factor
        mat = fitz.Matrix(x_zoom, y_zoom)
        mat = mat.preRotate(opts["rotation"])
        pix = page.getPixmap(matrix = mat, alpha=opts["alpha"])
        cmd = {'i': n + 1, 't': 'd', 's': pix.width, 'v': pix.height}
        if opts["alpha"]:
            cmd['f'] = 32
        else:
            cmd['f'] = 24
        if opts["tint"]:
            tint = fitz.utils.getColor(TINT_COLOR)
            red = int(tint[0] * 256)
            blue = int(tint[1] * 256)
            green = int(tint[2] * 256)
            pix.tintWith(red,blue,green)
        if opts["invert"]:
            pix.invertIRect()
        write_chunked(cmd, pix.samples)
        cmd = {'a': 'p', 'i': n + 1, 'z': ZINDEX}
        write_gr_cmd_with_response(cmd)
        is_stale[n] = False

def clean_quit(stdscr, doc):
    cmd = {'a': 'd', 'd': 'Z', 'z': ZINDEX}
    write_gr_cmd(cmd)
    stdscr.keypad(False)
    curses.echo()
    curses.curs_set(1)
    curses.endwin()
    doc.close()
    raise SystemExit()

def resize_handler(signum, frame):
    cmd = {'a': 'd', 'd': 'Z', 'z': ZINDEX}
    write_gr_cmd(cmd)
    screen_size = screen_size_function()
    ss_width = screen_size().width
    ss_height = screen_size().height
    return

def place_string(c,r,string):
    set_cursor(c,r)
    sys.stdout.write(string)
    sys.stdout.flush()

def update_status_bar(doc, n, cmd):
    p = str(n + 1)
    t = doc.pageCount
    c = screen_size().cols
    r = screen_size().rows
    left_bar = cmd + " " * 5
    place_string(1,r,left_bar)
    right_bar = '     [{}/{}]'.format(p, t)
    offset = c - len(right_bar)
    place_string(offset,r,right_bar)
    set_cursor(len(cmd) + 2,r)
    sys.stdout.flush()

def update_status_bar_c(status_bar, doc, n, cmd):
    p = str(n + 1)
    t = doc.pageCount
    r, c = status_bar.getmaxyx()
    left_bar = cmd + " " * 5
    status_bar.addstr(0,5,left_bar)
    right_bar = '     [{}/{}]'.format(p, t)
    offset = (c - 10) - len(right_bar)
    status_bar.addstr(0,offset,right_bar)
    status_bar.refresh()

def mark_all_pages_as_stale(pages):
    global is_stale
    is_stale = [True] * (pages + 1)

# Movement functions

def next_chapter(doc, n, count=1):
    toc = doc.getToC()
    if toc:
        for ch in toc:
            ch_page = ch[2] - 1
            if ch_page > n:
                count -= 1
            if count == 0:
                return ch_page 
        return ch_page # go to last chapter 
    else:
        return n

def prev_chapter(doc, n, count=1):
    toc = doc.getToC()
    if toc:
        for ch in reversed(toc):
            ch_page = ch[2] - 1
            if ch_page < n:
                count -= 1
            if count == 0:
                return ch_page 
        return ch_page # go to first chapter 
    else:
        return n

def goto_page(doc, current, target, opts):
    pages = doc.pageCount - 1
    if target > pages:
        target = pages
    elif target <= 0:
        target = 0
    return target

# Works in progress

def search_page(doc, current, search):
    results = doc.searchPageFor(current, search)
    clear_screen()
    print(results)
    raise SystemExit

def show_toc(doc,n):
    clear_screen()
    clear_page(n)
    toc = doc.getToC()
    toc_text = ''
    for sec in toc:
        toc_text += '{}{}'.format(" " * sec[0], sec[1]) 
    print(toc_text)
    raise SystemExit

# Main Viewer
def viewer(doc):

    stdscr = curses.initscr()
    stdscr.clear()
    curses.noecho()
    curses.curs_set(0) 
    stdscr.keypad(True) # Handle our own escape codes for now
    #stdscr.timeout(-1)
    stdscr.nodelay(True)
    stdscr.getch()
    
    # r, c = stdscr.getmaxyx()
    # status_bar = curses.newwin(0,c - 1,r - 1,1)

    pages = doc.pageCount - 1
    mark_all_pages_as_stale(pages)
    n = 0
    m = -1
    stack = [0] 
    count_string = ""
    opts = {"rotation": 0, "alpha": False, "invert": False, "tint": False}
   
    
    #tty.setraw(sys.stdin)
    runs = 0
    while True:

        # reload the after the first time, since getch seems to clobber
        # the image the first time around.
        if runs < 1:
            is_stale[n]
            runs = runs + 1
        else:
            stdscr.nodelay(False)

        # only update when changed page or image is stale
        if m != n or is_stale[n]: 
            display_page(doc, n, opts)
            update_status_bar(doc, n, str(runs))

        m = n

        # set count based on count_string
        if count_string == "":
            count = 1
        else:
            count = int(count_string)
 
        # get char
        char = stdscr.getch()

        # echo char to status_bar and clobber escape codes
        if char == 27: # ESC
            update_status_bar(doc, n, "")
        elif stack[0] == 27 and chr(char) == "_": # clobber ESC code
            update_status_bar(doc, n, '<STUCK> Press ESC\\ to resume.')
            r = b''
            while r[-2:] != b'\033\\':
                r += sys.stdin.buffer.read(1)
            update_status_bar(doc, n, '                        ')
            count_string = "" 
            stack = [0] 
        elif 32 < char < 256: # printable characters
            update_status_bar(doc, n, count_string + chr(char)) # echo input


        # perform actions based on character commands
        if char == -1:
            pass
        if char in range(48, 57): # increment count_string
            count_string = count_string + chr(char)
        else:
            if char in QUIT: 
                clean_quit(stdscr, doc)
            elif char in GOTO_PAGE:
                if count_string != "":
                   target = count - 1
                else: 
                   target = pages
                n = goto_page(doc, n, target, opts)
                stack = [0] 
            elif char in NEXT_PAGE:
                target = n + count
                n = goto_page(doc, n, target, opts)
                stack = [0] 
            elif char in PREV_PAGE:
                target = n - count
                n = goto_page(doc, n, target, opts)
                stack = [0] 
            elif char in NEXT_CHAP:
                target = next_chapter(doc, n, count)
                n = goto_page(doc, n, target, opts)
                stack = [0] 
            elif char in PREV_CHAP:
                target = prev_chapter(doc, n, count)
                n = goto_page(doc, n, target, opts)
                stack = [0] 
            elif stack[0] in GOTO and char in GOTO:
                n = goto_page(doc, n, 0, opts)
                stack = [0] 
            elif char in ROTATE_CW:
                opts["rotation"] = (opts["rotation"] + 90 * count) % 360
                mark_all_pages_as_stale(pages)
                stack = [0] 
            elif char in ROTATE_CCW:
                opts["rotation"] = (opts["rotation"] - 90 * count) % 360
                mark_all_pages_as_stale(pages)
                stack = [0] 
            elif char in TOGGLE_ALPHA:
                opts["alpha"] = not opts["alpha"]
                mark_all_pages_as_stale(pages)
                stack = [0] 
            elif char in TOGGLE_INVERT:
                opts["invert"]  = not opts["invert"]
                mark_all_pages_as_stale(pages)
                stack = [0] 
            elif char in TOGGLE_TINT:
                opts["tint"] = not opts["tint"]
                mark_all_pages_as_stale(pages)
                stack = [0] 
            elif char in REFRESH: # Ctrl-R
                mark_all_pages_as_stale(pages)
            elif char in DEBUG:
                # a spot for messing around with ideas
                # search_page(doc, n, "the")
                show_toc(doc,n)
                # pass
                stack = [0] 
            else:
                stack = [char] + stack
            
            if m != n or is_stale[m]:
                clear_page(m)
            count_string = ""


def main(args=sys.argv):
    global is_stale
    is_stale = []
    global screen_size
    screen_size = screen_size_function()
    if screen_size().width == 0:
        raise SystemExit(
            'Terminal does not support reporting screen sizes via the TIOCGWINSZ ioctl'
        )
    if len(args) != 2:
        raise SystemExit('You must specify exactly one file to view.')

    try:
        doc = fitz.open(args[1])
    except:
        raise SystemExit('Unable to open "{}".'.format(item))
    if not doc.isPDF:
        raise SystemExit('Document is not a PDF file')

    viewer(doc)

if __name__ == '__main__':
    main()

