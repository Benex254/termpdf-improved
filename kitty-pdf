#!/usr/bin/env python3
# vim:fileencoding=utf-8
"""\
Usage:
    kitty-pdf example.pdf

Options:
    currently, no options

Key Bindings:
    see the shortcuts at the beginning of the file
"""

__version__ = "0.1"
__license__ = "MIT"
__author__ = "David Sanson"
__url__ = "https://github.com/dsanson/kitty-pdf"

import array
import curses
import fcntl
import fitz
import os
import re
import readchar
import signal
import subprocess
import sys
import termios
import tty
import zlib
from base64 import standard_b64encode
from collections import namedtuple
from io import TextIOWrapper, BytesIO
from math import ceil
from time import sleep, monotonic

# Keyboard shortcuts
GOTO_PAGE     = {ord("G")}
GOTO          = {ord("g")}
NEXT_PAGE     = {ord("j"), ord(" ")}
PREV_PAGE     = {ord("k")}
NEXT_CHAP     = {ord("l")}
PREV_CHAP     = {ord("h")}
ROTATE_CW     = {ord("r")}
ROTATE_CCW    = {ord("R")}
TOGGLE_ALPHA  = {ord("a")}
TOGGLE_INVERT = {ord("i")}
TOGGLE_TINT   = {ord("t")}
REFRESH       = {18}            # CTRL-R
QUIT          = {3, ord("q")}
DEBUG         = {ord("D")}

# Defaults
TINT_COLOR    = "antiquewhite2"

def screen_size_function(fd=None):
    # ans = getattr(screen_size_function, 'ans', None)
    # if ans is None:
    Size = namedtuple('Size', 'rows cols width height cell_width cell_height')
    if fd is None:
        fd = sys.stdout

    def screen_size():
        if screen_size.changed:
            buf = array.array('H', [0, 0, 0, 0])
            fcntl.ioctl(fd, termios.TIOCGWINSZ, buf)
            rows, cols, width, height = tuple(buf)
            cell_width, cell_height = width // (cols or 1), height // (rows or 1)
            screen_size.ans = Size(rows, cols, width, height, cell_width, cell_height)
            screen_size.changed = False
        return screen_size.ans
    screen_size.changed = True
    screen_size.Size = Size
    ans = screen_size_function.ans = screen_size

    return ans

def serialize_gr_command(cmd, payload=None):
   cmd = ','.join('{}={}'.format(k, v) for k, v in cmd.items())
   ans = []
   w = ans.append
   w(b'\033_G'), w(cmd.encode('ascii'))
   if payload:
      w(b';')
      w(payload)
   w(b'\033\\')
   return b''.join(ans)

def write_gr_cmd(cmd, payload=None):
    sys.stdout.buffer.write(serialize_gr_command(cmd, payload))
    sys.stdout.flush()

def write_gr_cmd_with_response(cmd, payload=None):
    write_gr_cmd(cmd, payload)
    resp = b''
    while resp[-2:] != b'\033\\':
        resp += sys.stdin.buffer.read(1)
    if b'OK' in resp:
        return True
    else:
        return False

def write_chunked(cmd, data):
    if cmd['f'] != 100:
        data = zlib.compress(data)
        cmd['o'] = 'z'
    data = standard_b64encode(data)
    while data:
        chunk, data = data[:4096], data[4096:]
        m = 1 if data else 0
        cmd['m'] = m
        write_gr_cmd(cmd, chunk)
        cmd.clear()

def set_cursor(x_place, y_place):
    sys.stdout.buffer.write('\033[{};{}f'.format(y_place, x_place).encode('ascii'))

def set_image_cursor(display_width, display_height, ss_width, ss_height):
    x_place_pixels = (ss_width / 2) - (display_width / 2)
    x_place = int(ceil(x_place_pixels / screen_size().cell_width) - 1)
    y_place = 1
    set_cursor(x_place, y_place)

def clear_screen():
    subprocess.run('clear')
    cmd = {'a': 'd', 'd': 'Z', 'z': 0} 
    write_gr_cmd(cmd)

def clear_page(n):
    cmd = {'a': 'd', 'i': n + 1}
    write_gr_cmd(cmd)

def display_page(doc, n, opts):
    global is_stale
    page = doc.loadPage(n)
    if opts["rotation"] == 0 or opts["rotation"] == 180:
        page_width = page.bound().width
        page_height = page.bound().height
    else:
        page_width = page.bound().height
        page_height = page.bound().width
    screen_size = screen_size_function()
    ss_width = screen_size().width
    ss_height = screen_size().height
    x_factor = ss_width / page_width
    y_factor = (ss_height - screen_size().cell_height) / page_height
    factor = min(x_factor, y_factor)
    display_width = factor * page_width
    display_height = factor * page_height
    set_image_cursor(display_width, display_height, ss_width, ss_height)
    cmd = {'a': 'p', 'i': n + 1, 'z': 0}
    if is_stale[n] or not write_gr_cmd_with_response(cmd):
        x_zoom, y_zoom = factor, factor
        mat = fitz.Matrix(x_zoom, y_zoom)
        mat = mat.preRotate(opts["rotation"])
        pix = page.getPixmap(matrix = mat, alpha=opts["alpha"])
        cmd = {'i': n + 1, 't': 'd', 's': pix.width, 'v': pix.height}
        if opts["alpha"]:
            cmd['f'] = 32
        else:
            cmd['f'] = 24
        if opts["tint"]:
            tint = fitz.utils.getColor(TINT_COLOR)
            red = int(tint[0] * 256)
            blue = int(tint[1] * 256)
            green = int(tint[2] * 256)
            pix.tintWith(red,blue,green)
        if opts["invert"]:
            pix.invertIRect()
        write_chunked(cmd, pix.samples)
        cmd = {'a': 'p', 'i': n + 1, 'z': 0}
        write_gr_cmd_with_response(cmd)
        is_stale[n] = False

def clean_quit():
    curses.curs_set(1) # show the cursor
    #show_cursor()
    cmd = {'a': 'd', 'd': 'Z', 'z': 0}
    write_gr_cmd(cmd)
    raise SystemExit()

def resize_handler(signum, frame):
    cmd = {'a': 'd', 'd': 'Z', 'z': 0}
    write_gr_cmd(cmd)
    screen_size = screen_size_function()
    ss_width = screen_size().width
    ss_height = screen_size().height
    return

def refresh_images(*args):
    global is_stale
    is_stale = [True] * len(is_stale)

def display_bar(doc, n, cmd=" " * 10):
    p = str(n + 1)
    t = doc.pageCount
    r = screen_size().rows
    c = screen_size().cols
    left_bar = ' ' * 5 + '[{}/{}]'.format(p, t)
    set_cursor(c - len(left_bar), r)
    sys.stdout.write(left_bar)
    sys.stdout.flush()
    set_cursor(1,r)
    sys.stdout.write(cmd)
    sys.stdout.flush()

def refresh_screen(doc, n, opts):
    #clear_screen()
    display_page(doc, n, opts)
    display_bar(doc, n)
    return

def parse_toc(doc):
    toc = doc.getToC()
    return toc

def init_is_stale(pages):
    global is_stale
    is_stale = [True] * (pages + 1)

# Movement functions

def next_chapter(doc, n, count=1):
    toc = parse_toc(doc)
    if toc:
        for ch in toc:
            ch_page = ch[2] - 1
            if ch_page > n:
                count -= 1
            if count == 0:
                return ch_page 
        return ch_page # go to last chapter 
    else:
        return n

def prev_chapter(doc, n, count=1):
    toc = parse_toc(doc)
    if toc:
        for ch in reversed(toc):
            ch_page = ch[2] - 1
            if ch_page < n:
                count -= 1
            if count == 0:
                return ch_page 
        return ch_page # go to first chapter 
    else:
        return n

def goto_page(doc, current, target, opts):
    clear_page(current)
    pages = doc.pageCount - 1
    if target > pages:
        target = totalpages
    elif target <= 0:
        target = 0
    refresh_screen(doc, target, opts)
    return target

def search_page(doc, current, search):
    results = doc.searchPageFor(current, search)
    clear_screen()
    print(results)
    raise SystemExit

def viewer(doc):
    stdscr = curses.initscr()
    clear_screen()
    curses.curs_set(0) # hide cursor
    
    pages = doc.pageCount - 1
    init_is_stale(pages)

    n = 0
    prev = 0 # null character
    count_string = ""
    opts = {"rotation": 0, "alpha": False, "invert": False, "tint": False}

    tty.setraw(sys.stdin)
    refresh_screen(doc, n, opts)
    while True:
        if count_string == "":
            count = 1
        else:
            count = int(count_string)

        # read from buffer, so we can capture stray ESC codes
        raw_char = sys.stdin.buffer.read(1)
        if raw_char == b'\033':
            char = 27
        else:
            char = ord(raw_char.decode("utf-8"))
            display_bar(doc, n, count_string + chr(char)) # echo input
        if char in range(48, 57): # i.e., is a numeral
            count_string = count_string + chr(char)
        else:
            if prev == 27 and chr(char) == "_": # clobber stray ESC codes 
                r = b''
                while r[-2:] != b'\033\\':
                    r += sys.stdin.buffer.read(1)
                prev = 0
            # arrow commands
            elif prev == 27 and chr(char) == "[":
                char = sys.stdin.buffer.read(1)
                if char == b'A': # UP ARROW
                    target = n - 1
                    n = goto_page(doc, n, target, opts)
                elif char == b'B': # DOWN ARROW
                    target = n + 1
                    n = goto_page(doc, n, target, opts)
                elif char == b'C': # RIGHT ARROW
                    target = next_chapter(doc, n)
                    n = goto_page(doc, n, target, opts)
                elif char == b'D': # LEFT ARROW
                    target = prev_chapter(doc, n)
                    n = goto_page(doc, n, target, opts)
                char = 0
            elif char in QUIT: 
                clean_quit()
            # movement commands
            elif char in GOTO_PAGE:
                if count_string != "":
                   target = count - 1
                else: 
                   target = pages
                n = goto_page(doc, n, target, opts)
            elif char in NEXT_PAGE:
                target = n + count
                n = goto_page(doc, n, target, opts)
            elif char in PREV_PAGE:
                target = n - count
                n = goto_page(doc, n, target, opts)
            elif char in NEXT_CHAP:
                target = next_chapter(doc, n, count)
                n = goto_page(doc, n, target, opts)
            elif char in PREV_CHAP:
                target = prev_chapter(doc, n, count)
                n = goto_page(doc, n, target, opts)
            elif prev in GOTO and char in GOTO:
                n = goto_page(doc, n, 0, opts)
            elif char in ROTATE_CW:
                opts["rotation"] = (opts["rotation"] + 90 * count) % 360
                refresh_images()
                refresh_screen(doc, n, opts)
            elif char in ROTATE_CCW:
                opts["rotation"] = (opts["rotation"] - 90 * count) % 360
                refresh_images()
                refresh_screen(doc, n, opts)
            elif char in TOGGLE_ALPHA:
                opts["alpha"] = not opts["alpha"]
                refresh_images()
                refresh_screen(doc, n, opts)
            elif char in TOGGLE_INVERT:
                opts["invert"]  = not opts["invert"]
                refresh_images()
                refresh_screen(doc, n, opts)
            elif char in TOGGLE_TINT:
                opts["tint"] = not opts["tint"]
                refresh_images()
                refresh_screen(doc, n, opts)
            elif char in REFRESH: # Ctrl-R
                refresh_images()
                refresh_screen(doc, n, opts)
            elif char in DEBUG:
                # a spot for messing around with ideas
                # pass
                search_page(doc, n, "the")


            prev = char  
            count_string = ""

        
def open_file(item):
    try:
        doc = fitz.open(item)
    except:
        raise SystemExit('Unable to open "{}".'.format(item))
    if not doc.isPDF:
        raise SystemExit('Document is not a PDF file')
    viewer(doc)

def main(args=sys.argv):
    global screen_size
    global is_stale
    is_stale = []

    signal.signal(signal.SIGWINCH, refresh_images)

    screen_size = screen_size_function()
    if screen_size().width == 0:
        raise SystemExit(
            'Terminal does not support reporting screen sizes via the TIOCGWINSZ ioctl'
        )
    if len(args) != 2:
        raise SystemExit('You must specify exactly one file to view.')
    for item in args[1:]:
        open_file(item)

if __name__ == '__main__':
    main()

